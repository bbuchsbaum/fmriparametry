% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_parametric_hrf.R
\name{estimate_parametric_hrf}
\alias{estimate_parametric_hrf}
\title{Estimate parametric HRF parameters}
\usage{
estimate_parametric_hrf(
  fmri_data,
  event_model,
  parametric_hrf = "lwu",
  theta_seed = NULL,
  theta_bounds = NULL,
  confound_formula = NULL,
  baseline_model = "intercept",
  hrf_eval_times = NULL,
  hrf_span = 30,
  lambda_ridge = 0.01,
  mask = NULL,
  global_refinement = TRUE,
  global_passes = 3,
  convergence_epsilon = 0.01,
  kmeans_refinement = FALSE,
  kmeans_k = 5,
  kmeans_passes = 2,
  tiered_refinement = c("none", "moderate", "aggressive"),
  refinement_thresholds = list(r2_easy = 0.7, r2_hard = 0.3, se_low = 0.3, se_high = 0.7,
    gauss_newton_maxiter = 10),
  parallel = FALSE,
  n_cores = NULL,
  compute_se = TRUE,
  safety_mode = c("balanced", "maximum", "performance"),
  progress = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{fmri_data}{An fMRI dataset object or numeric matrix (timepoints x voxels)}

\item{event_model}{Event timing design matrix or event model object}

\item{parametric_hrf}{Character string specifying HRF model (currently "lwu")}

\item{theta_seed}{Initial parameters or "data_driven" for automatic selection}

\item{theta_bounds}{List with 'lower' and 'upper' bounds for parameters}

\item{confound_formula}{Optional formula for nuisance regressors}

\item{baseline_model}{Baseline model specification (default "intercept")}

\item{hrf_eval_times}{Time points for HRF evaluation}

\item{hrf_span}{Duration for HRF evaluation (default 30 seconds)}

\item{lambda_ridge}{Ridge penalty for stability (default 0.01)}

\item{mask}{Optional voxel selection mask}

\item{global_refinement}{Logical: perform iterative global refinement? (Sprint 2)}

\item{global_passes}{Number of global refinement iterations (default 3)}

\item{kmeans_refinement}{Logical: perform K-means local refinement? (Sprint 3)}

\item{kmeans_k}{Number of clusters for K-means (default 5)}

\item{kmeans_passes}{Number of K-means refinement passes (default 2)}

\item{tiered_refinement}{Character: refinement strategy ("none", "moderate", "aggressive")}

\item{refinement_thresholds}{List of RÂ² and SE thresholds for tiered refinement}

\item{parallel}{Logical: use parallel processing?}

\item{n_cores}{Number of cores for parallel processing (NULL = auto-detect)}

\item{compute_se}{Logical: compute standard errors?}

\item{safety_mode}{Character: "maximum", "balanced", or "performance"}

\item{progress}{Logical: show progress bar?}

\item{verbose}{Logical: print detailed messages?}
}
\value{
Object of class 'parametric_hrf_fit' containing:
\itemize{
\item estimated_parameters: Matrix of HRF parameters (voxels x parameters)
\item amplitudes: Response amplitudes for each voxel
\item standard_errors: Parameter standard errors (if computed)
\item fit_quality: List with R-squared and other metrics
\item convergence_info: Detailed convergence information
\item refinement_info: Information about refinement strategies applied
\item metadata: Complete analysis metadata
}
}
\description{
Estimate hemodynamic response function parameters from fMRI time series using
a parametric HRF model. Optional refinement steps improve fits for challenging
voxels.
}
\section{Package Options}{

Global iterative refinement (Stage 3) is controlled by the option
\code{fmriparametric.refine_global}. Set to \code{FALSE} to disable global re-centering
for all calls.
}

\examples{
# Simulated quick example
set.seed(1)
fmri_data <- matrix(rnorm(40), nrow = 20, ncol = 2)
events <- matrix(0, nrow = 20, ncol = 1)
events[c(5, 15), 1] <- 1
fit <- estimate_parametric_hrf(fmri_data, events, parametric_hrf = "lwu",
                               verbose = FALSE)
summary(fit)

}
